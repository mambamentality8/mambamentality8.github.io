# 页面发布

### 技术方案

本项目使用MQ实现页面发布的技术方案如下：

![1570117846058](C:\Users\85896\AppData\Roaming\Typora\typora-user-images\1570117846058.png)

```
技术方案说明：
1、平台包括多个站点，页面归属不同的站点。
2、发布一个页面应将该页面发布到所属站点的服务器上。
3、每个站点服务部署cms client程序，并与交换机绑定，绑定时指定站点Id为routingKey。 
指定站点id为routingKey就可以实现cms client只能接收到所属站点的页面发布消息。 
4、页面发布程序向MQ发布消息时指定页面所属站点Id为routingKey，将该页面发布到它所在服务器上的cms client。
路由模式分析如下：
发布一个页面，需发布到该页面所属的每个站点服务器，其它站点服务器不发布。 
比如：发布一个门户的页面，需要发布到每个门户服务器上，而用户中心服务器则不需要发布。 
所以本项目采用routing模式，用站点id作为routingKey，这样就可以匹配页面只发布到所属的站点服务器上。
```

页面发布流程图如下：

![1570117994284](C:\Users\85896\AppData\Roaming\Typora\typora-user-images\1570117994284.png)

```
1、前端请求cms执行页面发布。 
2、cms执行静态化程序生成html文件。 
3、cms将html文件存储到GridFS中。 
4、cms向MQ发送页面发布消息 
5、MQ将页面发布消息通知给Cms Client 
6、Cms Client从GridFS中下载html文件
7、Cms Client将html保存到所在服务器指定目录
```

### 需求分析

功能分析：
创建Cms Client工程作为页面发布消费方，将Cms Client部署在多个服务器上，它负责接收到页面发布 的消息后从 GridFS中下载文件在本地保存。
需求如下：
1、将cms Client部署在服务器，配置队列名称和  站点ID(Routingkey)。 
2、cms Client连接RabbitMQ并监听各自的“页面发布队列” 
3、cms Client接收页面发布队列的消息 
4、根据消息中的页面id从mongodb数据库下载页面到本地

调用dao查询页面信息，获取到页面的物理路径，调用dao查询站点信息，得到站点的物理路径 页面物理路径=站点物理路径+页面物理路径+页面名称。 
从GridFS查询静态文件内容，将静态文件内容保存到页面物理路径下。

### 消费方

创建maven工程 

继承父工程

#### 1.导入依赖

```
        <dependency>
            <groupId>com.xuecheng</groupId>
            <artifactId>xc-framework-model</artifactId>
            <version>1.0-SNAPSHOT</version>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-amqp</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-mongodb</artifactId>
        </dependency>
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-io</artifactId>
        </dependency>
        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>fastjson</artifactId>
        </dependency>
```

#### 2.配置文件

在resources下配置application.yml和logback-spring.xml。 

application.yml的内容如下：

```
server:
  port: 31000
spring:
  application:
    name: xc-service-manage-cms-client
  data:
    mongodb:
      uri:  mongodb://root:root@localhost:27017
      database: xc_cms
  rabbitmq:
    host: 127.0.0.1
    port: 5672
    username: guest
    password: guest
    virtualHost: /
xuecheng:
  mq:
    #cms客户端监控的队列名称（不同的客户端监控的队列不能重复）
    queue: queue_cms_postpage_01
    routingKey: 5a751fab6abb5044e0d19ea1	#此routingKey为门户站点ID
```

说明：在配置文件中配置队列的名称，每个 cms client在部署时注意队列名称不要重复



logback-spring.xml的内容如下：

```
<?xml version="1.0" encoding="UTF-8"?>

<configuration>
    <!--定义日志文件的存储地址,使用绝对路径-->
    <property name="LOG_HOME" value="e:/logs"/>

    <!-- Console 输出设置 -->
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符-->
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
            <charset>utf8</charset>
        </encoder>
    </appender>

    <!-- 按照每天生成日志文件 -->
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <!--日志文件输出的文件名-->
            <fileNamePattern>${LOG_HOME}/xc.%d{yyyy-MM-dd}.log</fileNamePattern>
        </rollingPolicy>
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>

    <!-- 异步输出 -->
    <appender name="ASYNC" class="ch.qos.logback.classic.AsyncAppender">
        <!-- 不丢失日志.默认的,如果队列的80%已满,则会丢弃TRACT、DEBUG、INFO级别的日志 -->
        <discardingThreshold>0</discardingThreshold>
        <!-- 更改默认的队列的深度,该值会影响性能.默认值为256 -->
        <queueSize>512</queueSize>
        <!-- 添加附加的appender,最多只能添加一个 -->
        <appender-ref ref="FILE"/>
    </appender>


    <logger name="org.apache.ibatis.cache.decorators.LoggingCache" level="DEBUG" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>
    <logger name="org.springframework.boot" level="DEBUG"/>
    <root level="info">
        <!--<appender-ref ref="ASYNC"/>-->
        <appender-ref ref="FILE"/>
        <appender-ref ref="CONSOLE"/>
    </root>
</configuration>
```

#### 3.启动类

```
@SpringBootApplication(exclude= {DataSourceAutoConfiguration.class})
@EntityScan("com.xuecheng.framework.domain.cms")//扫描实体类
@ComponentScan(basePackages={"com.xuecheng.framework"})//扫描common包下的类
@ComponentScan(basePackages={"com.xuecheng.manage_cms_client"})//扫描本项目下的所有类
public class ManageCmsClientApplication {
    public static void main(String[] args) {
        SpringApplication.run(ManageCmsClientApplication.class,args);
    }
}
```

#### 4.RabbitmqConﬁg配置类

消息队列设置如下：
1、创建“ex_cms_postpage”交换机
2、每个Cms Client创建一个队列与交换机绑定
3、每个Cms Client程序配置队列名称和routingKey，将站点ID作为routingKey。

```
package com.xuecheng.manage_cms_client.config;

import org.springframework.amqp.core.*;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * @author Administrator
 * @version 1.0
 **/
@Configuration
public class RabbitmqConfig {

    //队列bean的名称
    public static final String QUEUE_CMS_POSTPAGE = "queue_cms_postpage";
    //交换机的名称
    public static final String EX_ROUTING_CMS_POSTPAGE="ex_routing_cms_postpage";
    //队列的名称
    @Value("${xuecheng.mq.queue}")
    public  String queue_cms_postpage_name;
    //routingKey 即站点Id
    @Value("${xuecheng.mq.routingKey}")
    public  String routingKey;
    /**
     * 交换机配置使用direct类型
     * @return the exchange
     */
    @Bean(EX_ROUTING_CMS_POSTPAGE)
    public Exchange EXCHANGE_TOPICS_INFORM() {
        return ExchangeBuilder.directExchange(EX_ROUTING_CMS_POSTPAGE).durable(true).build();
    }
    //声明队列
    @Bean(QUEUE_CMS_POSTPAGE)
    public Queue QUEUE_CMS_POSTPAGE() {
        Queue queue = new Queue(queue_cms_postpage_name);
        return queue;
    }

    /**
     * 绑定队列到交换机
     *
     * @param queue    the queue
     * @param exchange the exchange
     * @return the binding
     */
    @Bean
    public Binding BINDING_QUEUE_INFORM_SMS(@Qualifier(QUEUE_CMS_POSTPAGE) Queue queue, @Qualifier(EX_ROUTING_CMS_POSTPAGE) Exchange exchange) {
        return BindingBuilder.bind(queue).to(exchange).with(routingKey).noargs();
    }

}
```

#### 5.定义消息格式

消息内容采用json格式存储数据，如下： 
页面id：发布页面的id

```
{
	"pageId":""
}
```

#### 6.PageDao

1、使用CmsPageRepository 查询页面信息

```
public interface CmsPageRepository extends MongoRepository<CmsPage,String> {

}
```

2、使用CmsSiteRepository查询站点信息，主要获取站点物理路径

```
public interface CmsSiteRepository extends MongoRepository<CmsSite,String> {

}
```

#### 7.PageService

在Service中定义保存页面静态文件到服务器物理路径方法：

```
package com.xuecheng.manage_cms_client.service;

import com.mongodb.client.gridfs.GridFSBucket;
import com.mongodb.client.gridfs.GridFSDownloadStream;
import com.mongodb.client.gridfs.model.GridFSFile;
import com.xuecheng.framework.domain.cms.CmsPage;
import com.xuecheng.framework.domain.cms.CmsSite;
import com.xuecheng.manage_cms_client.dao.CmsPageRepository;
import com.xuecheng.manage_cms_client.dao.CmsSiteRepository;
import org.apache.commons.io.IOUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.mongodb.core.query.Criteria;
import org.springframework.data.mongodb.core.query.Query;
import org.springframework.data.mongodb.gridfs.GridFsResource;
import org.springframework.data.mongodb.gridfs.GridFsTemplate;
import org.springframework.stereotype.Service;

import java.io.*;
import java.util.Optional;

/**
 * @author Administrator
 * @version 1.0
 **/
@Service
public class PageService {

    private static final Logger LOGGER = LoggerFactory.getLogger(PageService.class);

    @Autowired
    GridFsTemplate gridFsTemplate;

    @Autowired
    GridFSBucket gridFSBucket;

    @Autowired
    CmsPageRepository cmsPageRepository;

    @Autowired
    CmsSiteRepository cmsSiteRepository;

    //即将被中间件调用,中间件会传递过来一个数据pageId
    //保存html页面到服务器物理路径
    public void savePageToServerPath(String pageId) {

        //根据pageId查询cmsPage
        CmsPage cmsPage = this.findCmsPageById(pageId);
        //得到html的文件id，从cmsPage中获取htmlFileId内容
        String htmlFileId = cmsPage.getHtmlFileId();

        //从gridFS中查询html文件
        InputStream inputStream = this.getFileById(htmlFileId);
        if (inputStream == null) {
            LOGGER.error("getFileById InputStream is null ,htmlFileId:{}", htmlFileId);
            return;
        }

        //得到站点id
        String siteId = cmsPage.getSiteId();
        //得到站点的信息
        CmsSite cmsSite = this.findCmsSiteById(siteId);
        //得到站点的物理路径
        String sitePhysicalPath = cmsSite.getSitePhysicalPath();
        //得到页面的物理路径
        String pagePath = sitePhysicalPath + cmsPage.getPagePhysicalPath() + cmsPage.getPageName();


        //将html文件保存到服务器物理路径上
        //完成这个功能需要两个内容:
        //第一个就是输入流(从GridFS上获取)
        //第二个就是输出流输出流需要一个路径pagePath
        FileOutputStream fileOutputStream = null;
        try {
            fileOutputStream = new FileOutputStream(new File(pagePath));
            IOUtils.copy(inputStream, fileOutputStream);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            try {
                inputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
            try {
                fileOutputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }


    }


    //根据文件id从GridFS中查询文件内容
    public InputStream getFileById(String fileId) {
        //文件对象
        GridFSFile gridFSFile = gridFsTemplate.findOne(Query.query(Criteria.where("_id").is(fileId)));
        //打开下载流
        GridFSDownloadStream gridFSDownloadStream = gridFSBucket.openDownloadStream(gridFSFile.getObjectId());
        //定义GridFsResource
        GridFsResource gridFsResource = new GridFsResource(gridFSFile, gridFSDownloadStream);
        try {
            return gridFsResource.getInputStream();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }

    //根据页面id查询页面信息
    public CmsPage findCmsPageById(String pageId) {
        Optional<CmsPage> optional = cmsPageRepository.findById(pageId);
        if (optional.isPresent()) {
            return optional.get();
        }
        return null;
    }

    //根据站点id查询站点信息
    public CmsSite findCmsSiteById(String siteId) {
        Optional<CmsSite> optional = cmsSiteRepository.findById(siteId);
        if (optional.isPresent()) {
            return optional.get();
        }
        return null;
    }
}
```

#### 8.ConsumerPostPage

在cms client工程的mq包下创建ConsumerPostPage类，ConsumerPostPage作为发布页面的消费客户端，监听 页面发布队列的消息，收到消息后就开始调用PageService的savePageToServerPath方法。

```

```

### 生产方需求分析

管理员通过 cms系统发布“页面发布”的消费，cms系统作为页面发布的生产方。 需求如下： 
1、管理员进入管理界面点击“页面发布”，前端请求cms页面发布接口。 2、cms页面发布接口执行页面静态化，并将静态化页面存储至GridFS中。 3、静态化成功后，向消息队列发送页面发布的消息。
1） 获取页面的信息及页面所属站点ID。
2） 设置消息内容为页面ID。（采用json格式，方便日后扩展）
3） 发送消息给ex_cms_postpage交换机，并将站点ID作为routingKey。

### 生产方

#### 1.RabbitMQ配置

```
spring:
  rabbitmq:
    host: 127.0.0.1
    port: 5672
    username: guest
    password: guest
    virtualHost: /
```

#### 2.添加pom.xml

```
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-amqp</artifactId>
        </dependency>
```

#### 3.RabbitMQConﬁg配置

由于cms作为页面发布方要面对很多不同站点的服务器，面对很多页面发布队列，所以这里不再配置队列，只需要配置交换机即可。
在cms工程只配置交换机名称即可。

```
import org.springframework.amqp.core.Exchange;
import org.springframework.amqp.core.ExchangeBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * @author Administrator
 * @version 1.0
 **/
@Configuration
public class RabbitmqConfig {

    //交换机的名称
    public static final String EX_ROUTING_CMS_POSTPAGE="ex_routing_cms_postpage";
    /**
     * 交换机配置使用direct类型
     * @return the exchange
     */
    @Bean(EX_ROUTING_CMS_POSTPAGE)
    public Exchange EXCHANGE_TOPICS_INFORM() {
        return ExchangeBuilder.directExchange(EX_ROUTING_CMS_POSTPAGE).durable(true).build();
    }

}

```

#### 4.Api接口

在api工程定义页面发布接口：

```
    //页面发布
    @ApiOperation("页面发布")
    public ResponseResult post(String pageId);
```

#### 5.PageService

在PageService中定义页面发布方法，代码如下：

```
    //页面发布
    public ResponseResult post(String pageId){
        //执行页面静态化
        String pageHtml = this.getPageHtml(pageId);
        //将页面静态化文件存储到GridFs中
        CmsPage cmsPage = saveHtml(pageId, pageHtml);
        //向MQ发消息
        sendPostPage(pageId);
        return new ResponseResult(CommonCode.SUCCESS);
    }

    //向mq 发送消息
    private void sendPostPage(String pageId){
        //得到页面信息
        CmsPage cmsPage = this.getById(pageId);
        if(cmsPage == null){
            ExceptionCast.cast(CommonCode.INVALID_PARAM);
        }
        //创建消息对象
        Map<String,String> msg = new HashMap<>();
        msg.put("pageId",pageId);
        //转成json串
        String jsonString = JSON.toJSONString(msg);
        //发送给mq
        //站点id
        String siteId = cmsPage.getSiteId();
        rabbitTemplate.convertAndSend(RabbitmqConfig.EX_ROUTING_CMS_POSTPAGE,siteId,jsonString);
    }
    //保存html到GridFS
    private CmsPage saveHtml(String pageId,String htmlContent){
        //先得到页面信息
        CmsPage cmsPage = this.getById(pageId);
        if(cmsPage == null){
            ExceptionCast.cast(CommonCode.INVALID_PARAM);
        }
        ObjectId objectId = null;
        try {
            //将htmlContent内容转成输入流
            InputStream inputStream = IOUtils.toInputStream(htmlContent, "utf-8");
            //将html文件内容保存到GridFS
            objectId = gridFsTemplate.store(inputStream, cmsPage.getPageName());
        } catch (IOException e) {
            e.printStackTrace();
        }

        //将html文件id更新到cmsPage中
        //将gridFs返回的objectId当成HtmlFileId放在cmsPage中
        cmsPage.setHtmlFileId(objectId.toHexString());
        cmsPageRepository.save(cmsPage);
        return cmsPage;
    }
```

#### 6.CmsPageController

```
    @Override
    @PostMapping("/postPage/{pageId}")
    public ResponseResult post(@PathVariable("pageId") String pageId) {
        return pageService.post(pageId);
    }
```

#### 7.测试

使用SwaggerUI

```
http://localhost:31001/swagger-ui.html#!
```

#### 8.前端

修改page_list.vue，添加发布按钮

```
          <el-button
            size="small" type="text"
            @click="postPage(page.row.pageId)">发布
          </el-button>
```

添加页面发布事件：

```
      postPage(pageId) {
        this.$confirm('确认发布该页面吗?', '提示', {}).then(() => {
          cmsApi.page_postPage(pageId).then((res) => {
            if (res.success) {
              console.log('发布页面pageId=' + pageId);
              this.$message.success('发布成功，请稍后查看结果');
            } else {
              this.$message.error('发布失败');
            }
          });
        }).catch(() => {

        });
      },
```

#### 9.测试

1.执行页面发布，查看页面是否写到网站目录

2.刷新门户首页并观察轮播图是否变化。

# 课程管理

### 需求分析

在线教育平台的课程信息相当于电商平台的商品。课程管理是后台管理功能中最重要的模块。本项目为教学机构提供课程管理功能，教学机构可以添加属于自己的课程，供学生在线学习。

课程管理包括如下功能需求：

1、分类管理

2、新增课程

3、修改课程

4、预览课程

5、发布课程

用户的操作流程如下：

#### 1.进入我的课程

![1529027784483](file:///E:/%E4%BC%A0%E6%99%BA%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF/HTML%E7%89%88%E6%9C%AC%E5%AD%A6%E6%88%90%E8%AE%B2%E4%B9%89/day06-%E9%A1%B5%E9%9D%A2%E5%8F%91%E5%B8%83%20%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86/images/1529027784483.png)

#### 2.点击“添加课程”，进入添加课程界面

![1529027816864](file:///E:/%E4%BC%A0%E6%99%BA%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF/HTML%E7%89%88%E6%9C%AC%E5%AD%A6%E6%88%90%E8%AE%B2%E4%B9%89/day06-%E9%A1%B5%E9%9D%A2%E5%8F%91%E5%B8%83%20%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86/images/1529027816864.png)

#### 3.输入课程基本信息，点击提交

#### 4.课程基本信息提交成功，自动进入“管理课程”界面，点击“管理课程”也可以进入“管理课程”界面

![1529027905040](file:///E:/%E4%BC%A0%E6%99%BA%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF/HTML%E7%89%88%E6%9C%AC%E5%AD%A6%E6%88%90%E8%AE%B2%E4%B9%89/day06-%E9%A1%B5%E9%9D%A2%E5%8F%91%E5%B8%83%20%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86/images/1529027905040.png)

#### 5.编辑图片

上传课程图片。

![1537087921109](file:///E:/%E4%BC%A0%E6%99%BA%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF/HTML%E7%89%88%E6%9C%AC%E5%AD%A6%E6%88%90%E8%AE%B2%E4%B9%89/day06-%E9%A1%B5%E9%9D%A2%E5%8F%91%E5%B8%83%20%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86/images/1537087921109.png)

#### 6.编辑课程营销信息

营销信息主要是设置课程的收费方式及价格。

![1523610482568](file:///E:/%E4%BC%A0%E6%99%BA%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF/HTML%E7%89%88%E6%9C%AC%E5%AD%A6%E6%88%90%E8%AE%B2%E4%B9%89/day06-%E9%A1%B5%E9%9D%A2%E5%8F%91%E5%B8%83%20%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86/images/1523610482568.png)

#### 7.编辑课程计划

![1537088415675](file:///E:/%E4%BC%A0%E6%99%BA%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF/HTML%E7%89%88%E6%9C%AC%E5%AD%A6%E6%88%90%E8%AE%B2%E4%B9%89/day06-%E9%A1%B5%E9%9D%A2%E5%8F%91%E5%B8%83%20%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86/images/1537088415675.png)添加课程计划：

![1537088869032](file:///E:/%E4%BC%A0%E6%99%BA%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF/HTML%E7%89%88%E6%9C%AC%E5%AD%A6%E6%88%90%E8%AE%B2%E4%B9%89/day06-%E9%A1%B5%E9%9D%A2%E5%8F%91%E5%B8%83%20%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86/images/1537088869032.png)

### 环境搭建

#### 1.导入数据库

导入xc_course.sql脚本

![1523444082559](file:///E:/%E4%BC%A0%E6%99%BA%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF/HTML%E7%89%88%E6%9C%AC%E5%AD%A6%E6%88%90%E8%AE%B2%E4%B9%89/day06-%E9%A1%B5%E9%9D%A2%E5%8F%91%E5%B8%83%20%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86/images/1523444082559.png)

数据库表介绍

![1529028095795](file:///E:/%E4%BC%A0%E6%99%BA%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF/HTML%E7%89%88%E6%9C%AC%E5%AD%A6%E6%88%90%E8%AE%B2%E4%B9%89/day06-%E9%A1%B5%E9%9D%A2%E5%8F%91%E5%B8%83%20%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86/images/1529028095795.png)

数据表结构如下：

![1523461543531](file:///E:/%E4%BC%A0%E6%99%BA%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF/HTML%E7%89%88%E6%9C%AC%E5%AD%A6%E6%88%90%E8%AE%B2%E4%B9%89/day06-%E9%A1%B5%E9%9D%A2%E5%8F%91%E5%B8%83%20%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86/images/1523461543531.png)

![1529028158116](file:///E:/%E4%BC%A0%E6%99%BA%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF/HTML%E7%89%88%E6%9C%AC%E5%AD%A6%E6%88%90%E8%AE%B2%E4%B9%89/day06-%E9%A1%B5%E9%9D%A2%E5%8F%91%E5%B8%83%20%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86/images/1529028158116.png)

![1529028170062](file:///E:/%E4%BC%A0%E6%99%BA%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF/HTML%E7%89%88%E6%9C%AC%E5%AD%A6%E6%88%90%E8%AE%B2%E4%B9%89/day06-%E9%A1%B5%E9%9D%A2%E5%8F%91%E5%B8%83%20%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86/images/1529028170062.png)

![1529028187091](file:///E:/%E4%BC%A0%E6%99%BA%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF/HTML%E7%89%88%E6%9C%AC%E5%AD%A6%E6%88%90%E8%AE%B2%E4%B9%89/day06-%E9%A1%B5%E9%9D%A2%E5%8F%91%E5%B8%83%20%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86/images/1529028187091.png)

![1529028201623](file:///E:/%E4%BC%A0%E6%99%BA%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF/HTML%E7%89%88%E6%9C%AC%E5%AD%A6%E6%88%90%E8%AE%B2%E4%B9%89/day06-%E9%A1%B5%E9%9D%A2%E5%8F%91%E5%B8%83%20%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86/images/1529028201623.png)

grade 根节点代表课程标题  下一个阶段为大章节  下下一个阶段为小章节



#### 2.导入课程管理服务工程

xc-service-manage-course

断点运行test  测试mybatis 和 springDataJPA

#### 3.导入课程管理前端工程

坑:

```
Error: Node Sass does not yet support your current environment: Windows 64-bit with Unsupported runtime (64)
```

解决:

修改package.json,然后run npm install

```
"node-sass": "^4.12.0"
```



​	课程管理属于教学管理子系统的功能，使用用户为教学机构的管理人员和老师，为保证系统的可维护性，单独创建一个教学管理前端工程。	教学管理前端工程与系统管理前端的工程结构一样，也采用vue.js框架来实现。

![1523458363921](file:///E:/%E4%BC%A0%E6%99%BA%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF/HTML%E7%89%88%E6%9C%AC%E5%AD%A6%E6%88%90%E8%AE%B2%E4%B9%89/day06-%E9%A1%B5%E9%9D%A2%E5%8F%91%E5%B8%83%20%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86/images/1523458363921.png)

从课程资料目录拷贝xc-ui-pc-teach.zip到工程，使用webstorm打开，启动工程：

效果图如下：

![1537089947547](file:///E:/%E4%BC%A0%E6%99%BA%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF/HTML%E7%89%88%E6%9C%AC%E5%AD%A6%E6%88%90%E8%AE%B2%E4%B9%89/day06-%E9%A1%B5%E9%9D%A2%E5%8F%91%E5%B8%83%20%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86/images/1537089947547.png)

# 课程计划

### 需求分析

什么是课程计划？

课程计划定义了课程的章节内容，学生通过课程计划进行在线学习，下图中右侧显示的就是课程计划。

课程计划包括两级，第一级是课程的大章节、第二级是大章节下属的小章节，每个小章节通常是一段视频，学生点击小章节在线学习。

教学管理人员对课程计划如何管理？

功能包括：添加课程计划、删除课程计划、修改课程计划等。

![1529052509858](file:///E:/%E4%BC%A0%E6%99%BA%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF/HTML%E7%89%88%E6%9C%AC%E5%AD%A6%E6%88%90%E8%AE%B2%E4%B9%89/day06-%E9%A1%B5%E9%9D%A2%E5%8F%91%E5%B8%83%20%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86/images/1529052509858.png)

### 课程计划查询

课程计划查询是将某个课程的课程计划内容完整的显示出来，如下图所示：

![1529061483214](file:///E:/%E4%BC%A0%E6%99%BA%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF/HTML%E7%89%88%E6%9C%AC%E5%AD%A6%E6%88%90%E8%AE%B2%E4%B9%89/day06-%E9%A1%B5%E9%9D%A2%E5%8F%91%E5%B8%83%20%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86/images/1529061483214.png)

左侧显示的就是课程计划，课程计划是一个树型结构，方便扩展课程计划的级别。

在上边页面中，点击“添加课程计划”即可对课程计划进行添加操作。

点击修改可对某个章节内容进行修改。

点击删除可删除某个章节。

#### Tree组件介绍

本功能使用element-ui 的tree组件来完成

![1523613586138](file:///E:/%E4%BC%A0%E6%99%BA%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF/HTML%E7%89%88%E6%9C%AC%E5%AD%A6%E6%88%90%E8%AE%B2%E4%B9%89/day06-%E9%A1%B5%E9%9D%A2%E5%8F%91%E5%B8%83%20%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86/images/1523613586138.png)

在course_plan.vue文件中添加tree组件的代码，进行测试：

##### 1.组件标签

```
	<el-tree
      :data="data"
      show-checkbox
      node-key="id"
      default-expand-all
      :expand-on-click-node="false"
      :render-content="renderContent">
    </el-tree>
```

##### 2.数据对象

```
 let id = 1000;

  export default {
    data() {
      return {
        data : [{
          id: 1,
          label: '一级 1',
          children: [{
            id: 4,
            label: '二级 1-1',
            children: [{
              id: 9,
              label: '三级 1-1-1'
            }, {
              id: 10,
              label: '三级 1-1-2'
            }]
          }]
        }]
      }
     }
   }
```

##### 3.webstorm配置JSX

本组件用到了JSX语法，如下所示：

![1537091658093](file:///E:/%E4%BC%A0%E6%99%BA%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF/HTML%E7%89%88%E6%9C%AC%E5%AD%A6%E6%88%90%E8%AE%B2%E4%B9%89/day06-%E9%A1%B5%E9%9D%A2%E5%8F%91%E5%B8%83%20%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86/images/1537091658093.png)

​	JSX 是Javascript和XML结合的一种格式，它是React的核心组成部分，JSX和XML语法类似，可以定义属性以及子元素。唯一特殊的是可以用大括号来加入JavaScript表达式。遇到 HTML 标签（以 < 开头），就用 HTML 规则解析；遇到代码块（以 { 开头），就用 JavaScript 规则解析。

下面是官方的一个例子：

![1523613894745](file:///E:/%E4%BC%A0%E6%99%BA%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF/HTML%E7%89%88%E6%9C%AC%E5%AD%A6%E6%88%90%E8%AE%B2%E4%B9%89/day06-%E9%A1%B5%E9%9D%A2%E5%8F%91%E5%B8%83%20%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86/images/1523613894745.png)

设置方法 如下：

1、Javascript version 选择 React JSX （如果没有就选择JSX Harmony）

![1523615515485](file:///E:/%E4%BC%A0%E6%99%BA%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF/HTML%E7%89%88%E6%9C%AC%E5%AD%A6%E6%88%90%E8%AE%B2%E4%B9%89/day06-%E9%A1%B5%E9%9D%A2%E5%8F%91%E5%B8%83%20%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86/images/1523615515485.png)

2、HTML 类型文件中增加vue

![1523615618406](file:///E:/%E4%BC%A0%E6%99%BA%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF/HTML%E7%89%88%E6%9C%AC%E5%AD%A6%E6%88%90%E8%AE%B2%E4%B9%89/day06-%E9%A1%B5%E9%9D%A2%E5%8F%91%E5%B8%83%20%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86/images/1523615618406.png)

preferences -> Editor -> File Types 中找到上边框中HTML 在下边加一个 *.vue

如果已经在vue template 中已存在.vue 则把它改为*.vue2(因为要在Html中添加*.vue)

![1523615672165](file:///E:/%E4%BC%A0%E6%99%BA%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF/HTML%E7%89%88%E6%9C%AC%E5%AD%A6%E6%88%90%E8%AE%B2%E4%B9%89/day06-%E9%A1%B5%E9%9D%A2%E5%8F%91%E5%B8%83%20%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86/images/1523615672165.png)

#### API接口

##### 1.数据模型

表结构

![1529484678668](file:///E:/%E4%BC%A0%E6%99%BA%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF/HTML%E7%89%88%E6%9C%AC%E5%AD%A6%E6%88%90%E8%AE%B2%E4%B9%89/day06-%E9%A1%B5%E9%9D%A2%E5%8F%91%E5%B8%83%20%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86/images/1529484678668.png)

模型类

```
@Data
@ToString
@Entity
@Table(name="teachplan")
@GenericGenerator(name = "jpa-uuid", strategy = "uuid")
public class Teachplan implements Serializable {
    private static final long serialVersionUID = -916357110051689485L;
    @Id
    @GeneratedValue(generator = "jpa-uuid")
    @Column(length = 32)
    private String id;
    private String pname;
    private String parentid;
    private String grade;
    private String ptype;
    private String description;
    private String courseid;
    private String status;
    private Integer orderby;
    private Double timelength;
    private String trylearn;

}
```

##### 2.自定义模型类

```
@Data
@ToString
public class TeachplanNode extends Teachplan {
    List<TeachplanNode> children;
}
```

这样定义类可以保证前端页面树型结构的数据来展示Tree组件

```
	[{
      id: 1,
      label: '一级 1',
      children: [{
        id: 4,
        label: '二级 1-1'
       }]
     }]
```

本节点里面套本节点    子节点名叫children   children结构是数组    children里面又是Teachplan的属性值

TeachplanNode继承了Teachplan  所以  TeachplanNode也有Teachplan的属性

##### 3.接口定义

根据课程id查询课程的计划接口如下，在api工程创建course包，创建CourseControllerApi接口类并定义接口方法如下：

```
@Api(value="课程管理接口",description = "课程管理接口，提供课程的增、删、改、查")
public interface CourseControllerApi {
    @ApiOperation("课程计划查询")
    public TeachplanNode findTeachplanList(String courseId);
}
```

#### 课程管理服务

##### 1.sql

课程计划是树型结构，采用表的自连接方式进行查询，sql语句如下：

```
SELECT 
  a.id one_id,
  a.pname one_pname,
  b.id two_id,
  b.pname two_pname,
  c.id three_id,
  c.pname three_pname 
FROM
  teachplan a 
  LEFT JOIN teachplan b 
    ON a.id = b.parentid 
  LEFT JOIN teachplan c 
    ON b.id = c.parentid 
WHERE a.parentid = '0' 
  AND a.courseid = '402885816243d2dd016243f24c030002' 
ORDER BY a.orderby,
  b.orderby,
  c.orderby 
```

自关联的三张表  子节点的parentid  是  父节点的id  我要选出根节点的话  根节点的parentid一定是0

##### 2.Dao

1) mapper接口

```
@Mapper
public interface TeachplanMapper {
    public TeachplanNode selectList(String courseId);
}
```

2）mapper映射文件

```
    <resultMap id="teachplanMap" type="com.xuecheng.framework.domain.course.ext.TeachplanNode">
        <id column="one_id" property="id"></id>
        <result column="one_pname" property="pname"></result>
        <collection property="children" ofType="com.xuecheng.framework.domain.course.ext.TeachplanNode">
            <id column="two_id" property="id"></id>
            <result column="two_pname" property="pname"></result>
            <collection property="children" ofType="com.xuecheng.framework.domain.course.ext.TeachplanNode">
                <id column="three_id" property="id"></id>
                <result column="three_pname" property="pname"></result>
            </collection>
        </collection>

    </resultMap>

    <select id="selectList" parameterType="java.lang.String"
            resultMap="teachplanMap">
        SELECT
        a.id one_id,
        a.pname one_pname,
        b.id two_id,
        b.pname two_pname,
        c.id three_id,
        c.pname three_pname
        FROM
        teachplan a
        LEFT JOIN teachplan b
        ON b.parentid = a.id
        LEFT JOIN teachplan c
        ON c.parentid = b.id
        WHERE a.parentid = '0'
        <if test="_parameter !=null and _parameter!=''">
            AND a.courseid = #{courseId}
        </if>

        ORDER BY a.orderby,
        b.orderby,
        c.orderby
    </select>
```

其中:

```
<if test="_parameter != null" >，如果只有一个参数，那么_parameter 就代表该参数，如果有多个参数，那么_parameter 可以get(0)得到第一个参数。
```

##### 3.Service

创建CourseService类，定义查询课程计划方法。

```
@Service
public class CourseService {
    @Autowired
    TeachplanMapper teachplanMapper;
    //查询课程计划
    public TeachplanNode findTeachplanList(String courseId){
        TeachplanNode teachplanNode = teachplanMapper.selectList(courseId);
        return teachplanNode;
    }
}
```

##### 5.controller

```
@RestController
@RequestMapping("/course")
public class CourseController implements CourseControllerApi {
    @Autowired
    CourseService courseService;

    @Override
    @GetMapping("/teachplan/list/{courseId}")
    public TeachplanNode findTeachplanList(@PathVariable("courseId") String courseId) {
        return courseService.findTeachplanList(courseId);

    }
}
```

##### 6.测试

使用postman或swagger-ui测试查询接口。

Get 请求：http://localhost:31200/course/teachplan/list/402885816243d2dd016243f24c030002

#### 前端页面

##### 1.定义api方法

在src/moodule/course/api/course.js定义课程计划查询的api方法：

```
 /*查询课程计划*/
export const findTeachplanList = courseid => {
  return http.requestQuickGet(apiUrl+'/course/teachplan/list/'+courseid)
}
```

##### 2.api调用

在mounted钩子方法中查询  课程计划 



1）定义查询课程计划的方法，赋值给数据对象teachplanList

```
      findTeachplan(){
        courseApi.findTeachplanList(this.courseid).then((res) => {
          this.teachplanList = [];//清空树
          if(res.children){
            this.teachplanList = res.children;
          }
        });
      }
```

2）在mounted钩子中查询课程计划

```
    mounted(){
      //课程id
      this.courseid = this.$route.params.courseid;
      //课程计划
      this.findTeachplan();
    }
```

3）修改树结点的标签属性

课程计划信息中pname为结点的名称，需要修改树结点的标签属性方可正常显示课程计划名称，如下：

```
        defaultProps: {
          children: 'children',
          label: 'pname'
        },
```

##### 3.测试

在course_list.vue页面将

```
courses: [
          {
            id:'test01',
            name:'test01',
            pic:''
          },
          {
            id:'test02',
            name:'test02',
            pic:''
          }
          ],
```

里面的第一个对象的id替换掉改为

```
courses: [
          {
            id:'4028e581617f945f01617f9dabc40000',
            name:'test01',
            pic:''
          },
          {
            id:'test02',
            name:'test02',
            pic:''
          }
          ],
```

点击课程计划查看数据

![1570466588549](C:\Users\85896\AppData\Roaming\Typora\typora-user-images\1570466588549.png)

### 添加课程计划

#### 需求分析

用户操作流程：

1、进入课程计划页面，点击“添加课程计划”

2、打开添加课程计划页面，输入课程计划信息

![1537088869032](file:///E:/%E4%BC%A0%E6%99%BA%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF/HTML%E7%89%88%E6%9C%AC%E5%AD%A6%E6%88%90%E8%AE%B2%E4%B9%89/day06-%E9%A1%B5%E9%9D%A2%E5%8F%91%E5%B8%83%20%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86/images/1537088869032.png)

上选择级结点说明： 

不选择上级结点表示当前添加的课程计划的父结点就是课程的根结点。

当添加该课程时，在课程计划中还没有父节点的时候要自动添加该课程的名称作为根结点。

3、点击提交。

#### Api接口

##### 添加课程计划

```
@Api(value="课程管理接口",description = "课程管理接口，提供课程的增、删、改、查")
public interface CourseControllerApi {
    @ApiOperation("课程计划查询")
    public TeachplanNode findTeachplanList(String courseId);

    @ApiOperation("添加课程计划")
    public ResponseResult addTeachplan(Teachplan teachplan);
}
```

#### 课程管理服务

##### 1.Dao

```
public interface TeachplanRepository extends JpaRepository<Teachplan, String> {
   //定义方法根据课程id和父结点id查询出结点列表，可以使用此方法实现查询根结点
   //SELECT * FROM teachplan WHERE courseid = '297e7c7c62b888f00162b8a7dec20000' AND parentid='0'
   public List<Teachplan> findByCourseidAndParentid(String courseId,String parentId);
}
```

##### 2.Service

```
/**
     * 添加课程计划
     * 分为两种情况
     * 1.选择了上级节点
     * 2.没选择上级节点
     * @param teachplan
     * @return
     */
    @Transactional
    public ResponseResult addTeachplan(Teachplan teachplan) {

        if(teachplan == null ||
                StringUtils.isEmpty(teachplan.getPname()) ||
                StringUtils.isEmpty(teachplan.getCourseid())){
            ExceptionCast.cast(CommonCode.INVALID_PARAM);
        }
        //课程id
        String courseid = teachplan.getCourseid();
        //上级结点的id
        String parentid = teachplan.getParentid();
        if(StringUtils.isEmpty(parentid)){
            //如果上级节点没有选择
            //获取课程的根结点
            parentid = getTeachplanRoot(courseid);
        }
        //查询根结点信息
        Optional<Teachplan> optional = teachplanRepository.findById(parentid);
        Teachplan teachplan1 = optional.get();
        //父结点的级别
        String parent_grade = teachplan1.getGrade();
        //创建一个新结点准备添加
        Teachplan teachplanNew = new Teachplan();
        //将teachplan的属性拷贝到teachplanNew中
        BeanUtils.copyProperties(teachplan,teachplanNew);
        //要设置必要的属性
        teachplanNew.setParentid(parentid);
        if(parent_grade.equals("1")){
            teachplanNew.setGrade("2");
        }else{
            teachplanNew.setGrade("3");
        }
        teachplanNew.setStatus("0");//未发布
        teachplanRepository.save(teachplanNew);
        return new ResponseResult(CommonCode.SUCCESS);
    }

    //上级节点没有选择
    //1.获取到根节点万事大吉

    //2.没有获取到根节点,创建根节点
    //创建根节点选择的数据参考TeachplanRepository查到的数据
    public String getTeachplanRoot(String courseId){
        //校验课程id
        Optional<CourseBase> optional = courseBaseRepository.findById(courseId);
        if(!optional.isPresent()){
            return null;
        }

        CourseBase courseBase = optional.get();
        //调用dao查询teachplan表得到该课程的根结点
        List<Teachplan> teachplanList = teachplanRepository.findByCourseidAndParentid(courseId, "0");
        if(teachplanList == null || teachplanList.size()<=0){
            //新添加一个课程的根结点
            Teachplan teachplan = new Teachplan();
            teachplan.setCourseid(courseId);
            teachplan.setParentid("0");
            teachplan.setGrade("1");//一级结点
            teachplan.setStatus("0");
            teachplan.setPname(courseBase.getName());
            teachplanRepository.save(teachplan);
            return teachplan.getId();

        }
        //返回根结点的id
        return teachplanList.get(0).getId();

    }
```

##### 3.controller

```
    //添加课程计划
    @Override
    @PostMapping("/teachplan/add")
    public ResponseResult addTeachplan(@RequestBody  Teachplan teachplan) {
        return courseService.addTeachplan(teachplan);
    }
```

@RequestBody : 将页面json数据转化为java对象

##### 5.前端

