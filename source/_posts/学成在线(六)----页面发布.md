# 页面发布

### 技术方案

本项目使用MQ实现页面发布的技术方案如下：

![1570117846058](C:\Users\85896\AppData\Roaming\Typora\typora-user-images\1570117846058.png)

```
技术方案说明：
1、平台包括多个站点，页面归属不同的站点。
2、发布一个页面应将该页面发布到所属站点的服务器上。
3、每个站点服务部署cms client程序，并与交换机绑定，绑定时指定站点Id为routingKey。 
指定站点id为routingKey就可以实现cms client只能接收到所属站点的页面发布消息。 
4、页面发布程序向MQ发布消息时指定页面所属站点Id为routingKey，将该页面发布到它所在服务器上的cms client。
路由模式分析如下：
发布一个页面，需发布到该页面所属的每个站点服务器，其它站点服务器不发布。 
比如：发布一个门户的页面，需要发布到每个门户服务器上，而用户中心服务器则不需要发布。 
所以本项目采用routing模式，用站点id作为routingKey，这样就可以匹配页面只发布到所属的站点服务器上。
```

页面发布流程图如下：

![1570117994284](C:\Users\85896\AppData\Roaming\Typora\typora-user-images\1570117994284.png)

```
1、前端请求cms执行页面发布。 
2、cms执行静态化程序生成html文件。 
3、cms将html文件存储到GridFS中。 
4、cms向MQ发送页面发布消息 
5、MQ将页面发布消息通知给Cms Client 
6、Cms Client从GridFS中下载html文件
7、Cms Client将html保存到所在服务器指定目录
```

### 需求分析

功能分析：
创建Cms Client工程作为页面发布消费方，将Cms Client部署在多个服务器上，它负责接收到页面发布 的消息后从 GridFS中下载文件在本地保存。
需求如下：
1、将cms Client部署在服务器，配置队列名称和  站点ID(Routingkey)。 
2、cms Client连接RabbitMQ并监听各自的“页面发布队列” 
3、cms Client接收页面发布队列的消息 
4、根据消息中的页面id从mongodb数据库下载页面到本地

调用dao查询页面信息，获取到页面的物理路径，调用dao查询站点信息，得到站点的物理路径 页面物理路径=站点物理路径+页面物理路径+页面名称。 
从GridFS查询静态文件内容，将静态文件内容保存到页面物理路径下。

### 消费方

创建maven工程 

继承父工程

#### 1.导入依赖

```
        <dependency>
            <groupId>com.xuecheng</groupId>
            <artifactId>xc-framework-model</artifactId>
            <version>1.0-SNAPSHOT</version>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-amqp</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-mongodb</artifactId>
        </dependency>
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-io</artifactId>
        </dependency>
        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>fastjson</artifactId>
        </dependency>
```

#### 2.配置文件

在resources下配置application.yml和logback-spring.xml。 

application.yml的内容如下：

```
server:
  port: 31000
spring:
  application:
    name: xc-service-manage-cms-client
  data:
    mongodb:
      uri:  mongodb://root:root@localhost:27017
      database: xc_cms
  rabbitmq:
    host: 127.0.0.1
    port: 5672
    username: guest
    password: guest
    virtualHost: /
xuecheng:
  mq:
    #cms客户端监控的队列名称（不同的客户端监控的队列不能重复）
    queue: queue_cms_postpage_01
    routingKey: 5a751fab6abb5044e0d19ea1	#此routingKey为门户站点ID
```

说明：在配置文件中配置队列的名称，每个 cms client在部署时注意队列名称不要重复



logback-spring.xml的内容如下：

```
<?xml version="1.0" encoding="UTF-8"?>

<configuration>
    <!--定义日志文件的存储地址,使用绝对路径-->
    <property name="LOG_HOME" value="e:/logs"/>

    <!-- Console 输出设置 -->
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符-->
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
            <charset>utf8</charset>
        </encoder>
    </appender>

    <!-- 按照每天生成日志文件 -->
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <!--日志文件输出的文件名-->
            <fileNamePattern>${LOG_HOME}/xc.%d{yyyy-MM-dd}.log</fileNamePattern>
        </rollingPolicy>
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>

    <!-- 异步输出 -->
    <appender name="ASYNC" class="ch.qos.logback.classic.AsyncAppender">
        <!-- 不丢失日志.默认的,如果队列的80%已满,则会丢弃TRACT、DEBUG、INFO级别的日志 -->
        <discardingThreshold>0</discardingThreshold>
        <!-- 更改默认的队列的深度,该值会影响性能.默认值为256 -->
        <queueSize>512</queueSize>
        <!-- 添加附加的appender,最多只能添加一个 -->
        <appender-ref ref="FILE"/>
    </appender>


    <logger name="org.apache.ibatis.cache.decorators.LoggingCache" level="DEBUG" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>
    <logger name="org.springframework.boot" level="DEBUG"/>
    <root level="info">
        <!--<appender-ref ref="ASYNC"/>-->
        <appender-ref ref="FILE"/>
        <appender-ref ref="CONSOLE"/>
    </root>
</configuration>
```

#### 3.启动类

```
@SpringBootApplication(exclude= {DataSourceAutoConfiguration.class})
@EntityScan("com.xuecheng.framework.domain.cms")//扫描实体类
@ComponentScan(basePackages={"com.xuecheng.framework"})//扫描common包下的类
@ComponentScan(basePackages={"com.xuecheng.manage_cms_client"})//扫描本项目下的所有类
public class ManageCmsClientApplication {
    public static void main(String[] args) {
        SpringApplication.run(ManageCmsClientApplication.class,args);
    }
}
```

#### 4.RabbitmqConﬁg配置类

消息队列设置如下：
1、创建“ex_cms_postpage”交换机
2、每个Cms Client创建一个队列与交换机绑定
3、每个Cms Client程序配置队列名称和routingKey，将站点ID作为routingKey。

```
package com.xuecheng.manage_cms_client.config;

import org.springframework.amqp.core.*;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * @author Administrator
 * @version 1.0
 **/
@Configuration
public class RabbitmqConfig {

    //队列bean的名称
    public static final String QUEUE_CMS_POSTPAGE = "queue_cms_postpage";
    //交换机的名称
    public static final String EX_ROUTING_CMS_POSTPAGE="ex_routing_cms_postpage";
    //队列的名称
    @Value("${xuecheng.mq.queue}")
    public  String queue_cms_postpage_name;
    //routingKey 即站点Id
    @Value("${xuecheng.mq.routingKey}")
    public  String routingKey;
    /**
     * 交换机配置使用direct类型
     * @return the exchange
     */
    @Bean(EX_ROUTING_CMS_POSTPAGE)
    public Exchange EXCHANGE_TOPICS_INFORM() {
        return ExchangeBuilder.directExchange(EX_ROUTING_CMS_POSTPAGE).durable(true).build();
    }
    //声明队列
    @Bean(QUEUE_CMS_POSTPAGE)
    public Queue QUEUE_CMS_POSTPAGE() {
        Queue queue = new Queue(queue_cms_postpage_name);
        return queue;
    }

    /**
     * 绑定队列到交换机
     *
     * @param queue    the queue
     * @param exchange the exchange
     * @return the binding
     */
    @Bean
    public Binding BINDING_QUEUE_INFORM_SMS(@Qualifier(QUEUE_CMS_POSTPAGE) Queue queue, @Qualifier(EX_ROUTING_CMS_POSTPAGE) Exchange exchange) {
        return BindingBuilder.bind(queue).to(exchange).with(routingKey).noargs();
    }

}
```

#### 5.定义消息格式

消息内容采用json格式存储数据，如下： 
页面id：发布页面的id

```
{
	"pageId":""
}
```

#### 6.PageDao

1、使用CmsPageRepository 查询页面信息

```
public interface CmsPageRepository extends MongoRepository<CmsPage,String> {

}
```

2、使用CmsSiteRepository查询站点信息，主要获取站点物理路径

```
public interface CmsSiteRepository extends MongoRepository<CmsSite,String> {

}
```

#### 7.PageService

在Service中定义保存页面静态文件到服务器物理路径方法：

```
package com.xuecheng.manage_cms_client.service;

import com.mongodb.client.gridfs.GridFSBucket;
import com.mongodb.client.gridfs.GridFSDownloadStream;
import com.mongodb.client.gridfs.model.GridFSFile;
import com.xuecheng.framework.domain.cms.CmsPage;
import com.xuecheng.framework.domain.cms.CmsSite;
import com.xuecheng.manage_cms_client.dao.CmsPageRepository;
import com.xuecheng.manage_cms_client.dao.CmsSiteRepository;
import org.apache.commons.io.IOUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.mongodb.core.query.Criteria;
import org.springframework.data.mongodb.core.query.Query;
import org.springframework.data.mongodb.gridfs.GridFsResource;
import org.springframework.data.mongodb.gridfs.GridFsTemplate;
import org.springframework.stereotype.Service;

import java.io.*;
import java.util.Optional;

/**
 * @author Administrator
 * @version 1.0
 **/
@Service
public class PageService {

    private static final Logger LOGGER = LoggerFactory.getLogger(PageService.class);

    @Autowired
    GridFsTemplate gridFsTemplate;

    @Autowired
    GridFSBucket gridFSBucket;

    @Autowired
    CmsPageRepository cmsPageRepository;

    @Autowired
    CmsSiteRepository cmsSiteRepository;

    //即将被中间件调用,中间件会传递过来一个数据pageId
    //保存html页面到服务器物理路径
    public void savePageToServerPath(String pageId) {

        //根据pageId查询cmsPage
        CmsPage cmsPage = this.findCmsPageById(pageId);
        //得到html的文件id，从cmsPage中获取htmlFileId内容
        String htmlFileId = cmsPage.getHtmlFileId();

        //从gridFS中查询html文件
        InputStream inputStream = this.getFileById(htmlFileId);
        if (inputStream == null) {
            LOGGER.error("getFileById InputStream is null ,htmlFileId:{}", htmlFileId);
            return;
        }

        //得到站点id
        String siteId = cmsPage.getSiteId();
        //得到站点的信息
        CmsSite cmsSite = this.findCmsSiteById(siteId);
        //得到站点的物理路径
        String sitePhysicalPath = cmsSite.getSitePhysicalPath();
        //得到页面的物理路径
        String pagePath = sitePhysicalPath + cmsPage.getPagePhysicalPath() + cmsPage.getPageName();


        //将html文件保存到服务器物理路径上
        //完成这个功能需要两个内容:
        //第一个就是输入流(从GridFS上获取)
        //第二个就是输出流输出流需要一个路径pagePath
        FileOutputStream fileOutputStream = null;
        try {
            fileOutputStream = new FileOutputStream(new File(pagePath));
            IOUtils.copy(inputStream, fileOutputStream);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            try {
                inputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
            try {
                fileOutputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }


    }


    //根据文件id从GridFS中查询文件内容
    public InputStream getFileById(String fileId) {
        //文件对象
        GridFSFile gridFSFile = gridFsTemplate.findOne(Query.query(Criteria.where("_id").is(fileId)));
        //打开下载流
        GridFSDownloadStream gridFSDownloadStream = gridFSBucket.openDownloadStream(gridFSFile.getObjectId());
        //定义GridFsResource
        GridFsResource gridFsResource = new GridFsResource(gridFSFile, gridFSDownloadStream);
        try {
            return gridFsResource.getInputStream();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }

    //根据页面id查询页面信息
    public CmsPage findCmsPageById(String pageId) {
        Optional<CmsPage> optional = cmsPageRepository.findById(pageId);
        if (optional.isPresent()) {
            return optional.get();
        }
        return null;
    }

    //根据站点id查询站点信息
    public CmsSite findCmsSiteById(String siteId) {
        Optional<CmsSite> optional = cmsSiteRepository.findById(siteId);
        if (optional.isPresent()) {
            return optional.get();
        }
        return null;
    }
}
```

#### 8.ConsumerPostPage

在cms client工程的mq包下创建ConsumerPostPage类，ConsumerPostPage作为发布页面的消费客户端，监听 页面发布队列的消息，收到消息后就开始调用PageService的savePageToServerPath方法。

```

```

### 生产方需求分析

管理员通过 cms系统发布“页面发布”的消费，cms系统作为页面发布的生产方。 需求如下： 
1、管理员进入管理界面点击“页面发布”，前端请求cms页面发布接口。 2、cms页面发布接口执行页面静态化，并将静态化页面存储至GridFS中。 3、静态化成功后，向消息队列发送页面发布的消息。
1） 获取页面的信息及页面所属站点ID。
2） 设置消息内容为页面ID。（采用json格式，方便日后扩展）
3） 发送消息给ex_cms_postpage交换机，并将站点ID作为routingKey。

### 生产方

#### 1.RabbitMQ配置

```
spring:
  rabbitmq:
    host: 127.0.0.1
    port: 5672
    username: guest
    password: guest
    virtualHost: /
```

#### 2.添加pom.xml

```
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-amqp</artifactId>
        </dependency>
```

#### 3.RabbitMQConﬁg配置

由于cms作为页面发布方要面对很多不同站点的服务器，面对很多页面发布队列，所以这里不再配置队列，只需要配置交换机即可。
在cms工程只配置交换机名称即可。

```
import org.springframework.amqp.core.Exchange;
import org.springframework.amqp.core.ExchangeBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * @author Administrator
 * @version 1.0
 **/
@Configuration
public class RabbitmqConfig {

    //交换机的名称
    public static final String EX_ROUTING_CMS_POSTPAGE="ex_routing_cms_postpage";
    /**
     * 交换机配置使用direct类型
     * @return the exchange
     */
    @Bean(EX_ROUTING_CMS_POSTPAGE)
    public Exchange EXCHANGE_TOPICS_INFORM() {
        return ExchangeBuilder.directExchange(EX_ROUTING_CMS_POSTPAGE).durable(true).build();
    }

}

```

#### 4.Api接口

在api工程定义页面发布接口：

```
    //页面发布
    @ApiOperation("页面发布")
    public ResponseResult post(String pageId);
```

#### 5.PageService

在PageService中定义页面发布方法，代码如下：

```
    //页面发布
    public ResponseResult post(String pageId){
        //执行页面静态化
        String pageHtml = this.getPageHtml(pageId);
        //将页面静态化文件存储到GridFs中
        CmsPage cmsPage = saveHtml(pageId, pageHtml);
        //向MQ发消息
        sendPostPage(pageId);
        return new ResponseResult(CommonCode.SUCCESS);
    }

    //向mq 发送消息
    private void sendPostPage(String pageId){
        //得到页面信息
        CmsPage cmsPage = this.getById(pageId);
        if(cmsPage == null){
            ExceptionCast.cast(CommonCode.INVALID_PARAM);
        }
        //创建消息对象
        Map<String,String> msg = new HashMap<>();
        msg.put("pageId",pageId);
        //转成json串
        String jsonString = JSON.toJSONString(msg);
        //发送给mq
        //站点id
        String siteId = cmsPage.getSiteId();
        rabbitTemplate.convertAndSend(RabbitmqConfig.EX_ROUTING_CMS_POSTPAGE,siteId,jsonString);
    }
    //保存html到GridFS
    private CmsPage saveHtml(String pageId,String htmlContent){
        //先得到页面信息
        CmsPage cmsPage = this.getById(pageId);
        if(cmsPage == null){
            ExceptionCast.cast(CommonCode.INVALID_PARAM);
        }
        ObjectId objectId = null;
        try {
            //将htmlContent内容转成输入流
            InputStream inputStream = IOUtils.toInputStream(htmlContent, "utf-8");
            //将html文件内容保存到GridFS
            objectId = gridFsTemplate.store(inputStream, cmsPage.getPageName());
        } catch (IOException e) {
            e.printStackTrace();
        }

        //将html文件id更新到cmsPage中
        //将gridFs返回的objectId当成HtmlFileId放在cmsPage中
        cmsPage.setHtmlFileId(objectId.toHexString());
        cmsPageRepository.save(cmsPage);
        return cmsPage;
    }
```

#### 6.CmsPageController

```
    @Override
    @PostMapping("/postPage/{pageId}")
    public ResponseResult post(@PathVariable("pageId") String pageId) {
        return pageService.post(pageId);
    }
```

#### 7.测试

使用SwaggerUI

```
http://localhost:31001/swagger-ui.html#!
```

#### 8.前端

修改page_list.vue，添加发布按钮

```
          <el-button
            size="small" type="text"
            @click="postPage(page.row.pageId)">发布
          </el-button>
```

添加页面发布事件：

```
      postPage(pageId) {
        this.$confirm('确认发布该页面吗?', '提示', {}).then(() => {
          cmsApi.page_postPage(pageId).then((res) => {
            if (res.success) {
              console.log('发布页面pageId=' + pageId);
              this.$message.success('发布成功，请稍后查看结果');
            } else {
              this.$message.error('发布失败');
            }
          });
        }).catch(() => {

        });
      },
```

#### 9.测试

1.执行页面发布，查看页面是否写到网站目录

2.刷新门户首页并观察轮播图是否变化。

# 课程管理

### 需求分析

在线教育平台的课程信息相当于电商平台的商品。课程管理是后台管理功能中最重要的模块。本项目为教学机构提供课程管理功能，教学机构可以添加属于自己的课程，供学生在线学习。

课程管理包括如下功能需求：

1、分类管理

2、新增课程

3、修改课程

4、预览课程

5、发布课程

用户的操作流程如下：

#### 1.进入我的课程

![1529027784483](file:///E:/%E4%BC%A0%E6%99%BA%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF/HTML%E7%89%88%E6%9C%AC%E5%AD%A6%E6%88%90%E8%AE%B2%E4%B9%89/day06-%E9%A1%B5%E9%9D%A2%E5%8F%91%E5%B8%83%20%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86/images/1529027784483.png)

#### 2.点击“添加课程”，进入添加课程界面

![1529027816864](file:///E:/%E4%BC%A0%E6%99%BA%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF/HTML%E7%89%88%E6%9C%AC%E5%AD%A6%E6%88%90%E8%AE%B2%E4%B9%89/day06-%E9%A1%B5%E9%9D%A2%E5%8F%91%E5%B8%83%20%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86/images/1529027816864.png)

#### 3.输入课程基本信息，点击提交

#### 4.课程基本信息提交成功，自动进入“管理课程”界面，点击“管理课程”也可以进入“管理课程”界面

![1529027905040](file:///E:/%E4%BC%A0%E6%99%BA%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF/HTML%E7%89%88%E6%9C%AC%E5%AD%A6%E6%88%90%E8%AE%B2%E4%B9%89/day06-%E9%A1%B5%E9%9D%A2%E5%8F%91%E5%B8%83%20%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86/images/1529027905040.png)

#### 5.编辑图片

上传课程图片。

![1537087921109](file:///E:/%E4%BC%A0%E6%99%BA%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF/HTML%E7%89%88%E6%9C%AC%E5%AD%A6%E6%88%90%E8%AE%B2%E4%B9%89/day06-%E9%A1%B5%E9%9D%A2%E5%8F%91%E5%B8%83%20%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86/images/1537087921109.png)

#### 6.编辑课程营销信息

营销信息主要是设置课程的收费方式及价格。

![1523610482568](file:///E:/%E4%BC%A0%E6%99%BA%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF/HTML%E7%89%88%E6%9C%AC%E5%AD%A6%E6%88%90%E8%AE%B2%E4%B9%89/day06-%E9%A1%B5%E9%9D%A2%E5%8F%91%E5%B8%83%20%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86/images/1523610482568.png)

#### 7.编辑课程计划

![1537088415675](file:///E:/%E4%BC%A0%E6%99%BA%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF/HTML%E7%89%88%E6%9C%AC%E5%AD%A6%E6%88%90%E8%AE%B2%E4%B9%89/day06-%E9%A1%B5%E9%9D%A2%E5%8F%91%E5%B8%83%20%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86/images/1537088415675.png)添加课程计划：

![1537088869032](file:///E:/%E4%BC%A0%E6%99%BA%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF/HTML%E7%89%88%E6%9C%AC%E5%AD%A6%E6%88%90%E8%AE%B2%E4%B9%89/day06-%E9%A1%B5%E9%9D%A2%E5%8F%91%E5%B8%83%20%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86/images/1537088869032.png)

### 环境搭建

#### 1.导入数据库

导入xc_course.sql脚本

![1523444082559](file:///E:/%E4%BC%A0%E6%99%BA%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF/HTML%E7%89%88%E6%9C%AC%E5%AD%A6%E6%88%90%E8%AE%B2%E4%B9%89/day06-%E9%A1%B5%E9%9D%A2%E5%8F%91%E5%B8%83%20%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86/images/1523444082559.png)

数据库表介绍

![1529028095795](file:///E:/%E4%BC%A0%E6%99%BA%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF/HTML%E7%89%88%E6%9C%AC%E5%AD%A6%E6%88%90%E8%AE%B2%E4%B9%89/day06-%E9%A1%B5%E9%9D%A2%E5%8F%91%E5%B8%83%20%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86/images/1529028095795.png)

数据表结构如下：

![1523461543531](file:///E:/%E4%BC%A0%E6%99%BA%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF/HTML%E7%89%88%E6%9C%AC%E5%AD%A6%E6%88%90%E8%AE%B2%E4%B9%89/day06-%E9%A1%B5%E9%9D%A2%E5%8F%91%E5%B8%83%20%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86/images/1523461543531.png)

![1529028158116](file:///E:/%E4%BC%A0%E6%99%BA%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF/HTML%E7%89%88%E6%9C%AC%E5%AD%A6%E6%88%90%E8%AE%B2%E4%B9%89/day06-%E9%A1%B5%E9%9D%A2%E5%8F%91%E5%B8%83%20%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86/images/1529028158116.png)

![1529028170062](file:///E:/%E4%BC%A0%E6%99%BA%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF/HTML%E7%89%88%E6%9C%AC%E5%AD%A6%E6%88%90%E8%AE%B2%E4%B9%89/day06-%E9%A1%B5%E9%9D%A2%E5%8F%91%E5%B8%83%20%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86/images/1529028170062.png)

![1529028187091](file:///E:/%E4%BC%A0%E6%99%BA%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF/HTML%E7%89%88%E6%9C%AC%E5%AD%A6%E6%88%90%E8%AE%B2%E4%B9%89/day06-%E9%A1%B5%E9%9D%A2%E5%8F%91%E5%B8%83%20%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86/images/1529028187091.png)

![1529028201623](file:///E:/%E4%BC%A0%E6%99%BA%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF/HTML%E7%89%88%E6%9C%AC%E5%AD%A6%E6%88%90%E8%AE%B2%E4%B9%89/day06-%E9%A1%B5%E9%9D%A2%E5%8F%91%E5%B8%83%20%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86/images/1529028201623.png)

grade 根节点代表课程标题  下一个阶段为大章节  下下一个阶段为小章节



#### 2.导入课程管理服务工程

xc-service-manage-course

断点运行test  测试mybatis 和 springDataJPA

#### 3.导入课程管理前端工程

坑:

```
Error: Node Sass does not yet support your current environment: Windows 64-bit with Unsupported runtime (64)
```

解决:

修改package.json,然后run npm install

```
"node-sass": "^4.12.0"
```



​	课程管理属于教学管理子系统的功能，使用用户为教学机构的管理人员和老师，为保证系统的可维护性，单独创建一个教学管理前端工程。	教学管理前端工程与系统管理前端的工程结构一样，也采用vue.js框架来实现。

![1523458363921](file:///E:/%E4%BC%A0%E6%99%BA%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF/HTML%E7%89%88%E6%9C%AC%E5%AD%A6%E6%88%90%E8%AE%B2%E4%B9%89/day06-%E9%A1%B5%E9%9D%A2%E5%8F%91%E5%B8%83%20%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86/images/1523458363921.png)

从课程资料目录拷贝xc-ui-pc-teach.zip到工程，使用webstorm打开，启动工程：

效果图如下：

![1537089947547](file:///E:/%E4%BC%A0%E6%99%BA%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF/HTML%E7%89%88%E6%9C%AC%E5%AD%A6%E6%88%90%E8%AE%B2%E4%B9%89/day06-%E9%A1%B5%E9%9D%A2%E5%8F%91%E5%B8%83%20%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86/images/1537089947547.png)

# 课程计划

### 需求分析

什么是课程计划？

课程计划定义了课程的章节内容，学生通过课程计划进行在线学习，下图中右侧显示的就是课程计划。

课程计划包括两级，第一级是课程的大章节、第二级是大章节下属的小章节，每个小章节通常是一段视频，学生点击小章节在线学习。

教学管理人员对课程计划如何管理？

功能包括：添加课程计划、删除课程计划、修改课程计划等。

![1529052509858](file:///E:/%E4%BC%A0%E6%99%BA%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF/HTML%E7%89%88%E6%9C%AC%E5%AD%A6%E6%88%90%E8%AE%B2%E4%B9%89/day06-%E9%A1%B5%E9%9D%A2%E5%8F%91%E5%B8%83%20%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86/images/1529052509858.png)

### 课程计划查询

课程计划查询是将某个课程的课程计划内容完整的显示出来，如下图所示：

![1529061483214](file:///E:/%E4%BC%A0%E6%99%BA%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF/HTML%E7%89%88%E6%9C%AC%E5%AD%A6%E6%88%90%E8%AE%B2%E4%B9%89/day06-%E9%A1%B5%E9%9D%A2%E5%8F%91%E5%B8%83%20%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86/images/1529061483214.png)

左侧显示的就是课程计划，课程计划是一个树型结构，方便扩展课程计划的级别。

在上边页面中，点击“添加课程计划”即可对课程计划进行添加操作。

点击修改可对某个章节内容进行修改。

点击删除可删除某个章节。

#### Tree组件介绍

#### API接口

##### 1.数据模型

表结构

![1529484678668](file:///E:/%E4%BC%A0%E6%99%BA%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF/HTML%E7%89%88%E6%9C%AC%E5%AD%A6%E6%88%90%E8%AE%B2%E4%B9%89/day06-%E9%A1%B5%E9%9D%A2%E5%8F%91%E5%B8%83%20%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86/images/1529484678668.png)

模型类

```
@Data
@ToString
@Entity
@Table(name="teachplan")
@GenericGenerator(name = "jpa-uuid", strategy = "uuid")
public class Teachplan implements Serializable {
    private static final long serialVersionUID = -916357110051689485L;
    @Id
    @GeneratedValue(generator = "jpa-uuid")
    @Column(length = 32)
    private String id;
    private String pname;
    private String parentid;
    private String grade;
    private String ptype;
    private String description;
    private String courseid;
    private String status;
    private Integer orderby;
    private Double timelength;
    private String trylearn;

}
```

##### 2.自定义模型类

```
@Data
@ToString
public class TeachplanNode extends Teachplan {
    List<TeachplanNode> children;
}
```

这样定义类可以保证前端页面树型结构的数据来展示Tree组件

```
	[{
      id: 1,
      label: '一级 1',
      children: [{
        id: 4,
        label: '二级 1-1'
       }]
     }]
```

本节点里面套本节点    子节点名叫children   children结构是数组    children里面又是Teachplan的属性值

TeachplanNode继承了Teachplan  所以  TeachplanNode也有Teachplan的属性

##### 3.接口定义

根据课程id查询课程的计划接口如下，在api工程创建course包，创建CourseControllerApi接口类并定义接口方法如下：

```
public interface CourseControllerApi {
    @ApiOperation("课程计划查询")
    public TeachplanNode findTeachplanList(String courseId);
}
```

#### 课程管理服务

##### 1.sql

课程计划是树型结构，采用表的自连接方式进行查询，sql语句如下：

```
SELECT 
  a.id one_id,
  a.pname one_pname,
  b.id two_id,
  b.pname two_pname,
  c.id three_id,
  c.pname three_pname 
FROM
  teachplan a 
  LEFT JOIN teachplan b 
    ON a.id = b.parentid 
  LEFT JOIN teachplan c 
    ON b.id = c.parentid 
WHERE a.parentid = '0' 
  AND a.courseid = '402885816243d2dd016243f24c030002' 
ORDER BY a.orderby,
  b.orderby,
  c.orderby 
```

自关联的三张表  子节点的parentid  是  父节点的id  我要选出根节点的话  根节点的parentid一定是0

##### 2.Dao

1) mapper接口

```
@Mapper
public interface TeachplanMapper {
    public TeachplanNode selectList(String courseId);
}
```

2）mapper映射文件

```
    <resultMap id="teachplanMap" type="com.xuecheng.framework.domain.course.ext.TeachplanNode">
        <id column="one_id" property="id"></id>
        <result column="one_pname" property="pname"></result>
        <collection property="children" ofType="com.xuecheng.framework.domain.course.ext.TeachplanNode">
            <id column="two_id" property="id"></id>
            <result column="two_pname" property="pname"></result>
            <collection property="children" ofType="com.xuecheng.framework.domain.course.ext.TeachplanNode">
                <id column="three_id" property="id"></id>
                <result column="three_pname" property="pname"></result>
            </collection>
        </collection>

    </resultMap>

    <select id="selectList" parameterType="java.lang.String"
            resultMap="teachplanMap">
        SELECT
        a.id one_id,
        a.pname one_pname,
        b.id two_id,
        b.pname two_pname,
        c.id three_id,
        c.pname three_pname
        FROM
        teachplan a
        LEFT JOIN teachplan b
        ON b.parentid = a.id
        LEFT JOIN teachplan c
        ON c.parentid = b.id
        WHERE a.parentid = '0'
        <if test="_parameter !=null and _parameter!=''">
            AND a.courseid = #{courseId}
        </if>

        ORDER BY a.orderby,
        b.orderby,
        c.orderby
    </select>
```

其中:

```
<if test="_parameter != null" >，如果只有一个参数，那么_parameter 就代表该参数，如果有多个参数，那么_parameter 可以get(0)得到第一个参数。
```

##### 3.Service

创建CourseService类，定义查询课程计划方法。

```
@Service
public class CourseService {
    @Autowired
    TeachplanMapper teachplanMapper;
    //查询课程计划
    public TeachplanNode findTeachplanList(String courseId){
        TeachplanNode teachplanNode = teachplanMapper.selectList(courseId);
        return teachplanNode;
    }
}
```

##### 5.controller

```
@RestController
@RequestMapping("/course")
public class CourseController implements CourseControllerApi {
    @Autowired
    CourseService courseService;

    //查询课程计划
    @Override
    @GetMapping("/teachplan/list/{courseId}")
    public TeachplanNode findTeachplanList(String courseId) {
        return courseService.findTeachplanList(courseId);
    }
}
```

##### 6.测试

使用postman或swagger-ui测试查询接口。

Get 请求：http://localhost:31200/course/teachplan/list/402885816243d2dd016243f24c030002