---
title: 汇编大法
top: 9977
tags: []
date: 2019-03-09 23:11:21
permalink:
categories: 逆向
image:

---

<p class="description"></p>

<meta name="referrer" content="no-referrer" />

<img src="http://blog-mamba.oss-cn-beijing.aliyuncs.com/springboot/title.png">

<!-- more -->

Windows逆向环境搭建

```

```

### 寄存器

- ollydbg的简介

![1562135783188](https://blog-mamba.oss-cn-beijing.aliyuncs.com/compilation/01.png)



- 寄存器

  - EAX
  
  - ECX
  
  - EBX

  - ESP 
  
    - 它永远指向堆栈窗口的最顶端
  
  - EBP

  - ESI

  - EDI

  - EIP
  
    - 指向当前即将要执行的指令,在CPU窗口有对应的地址值,CPU下次就要执行这个地址的指令
  - EIP是没有修改数值的菜单的,只能在CPU窗口的某一行右键此处为新EIP才可以改变EIP的值
    
    
  
- 32位寄存器

  - EAX :  12345678 (十六进制的数)
  -   AX :           5678
  -   AH :          56
  -   AL  :              78

  如果碰到cmp al,bl

  ​	比较的就是后两位78

  这种高八位  第八位只能用在EAX  ECX  EDX  EBX身上





- EIP的下方是标志位寄存器

  - C
    - 进位标志
    - 无符号运算结果 最大值累加1
    - C标志变为1

  - P
    - 奇偶标志
    - 在CPU窗口执行一个指令,如果把结果转化为二进制以后,数字1的个数为偶数的话P就为1
    - 同样将EAX的值改为0x00000000  add eax,0x1
    - 那么EAX的值为00000001
    - 同时P的值为0
    - 当EAX的值达到0x00000011时
    - P的值也达到了1
    - 如果想多次添加1只需要在CPU的窗口使用设置新的EIP,然后在使用F8

  - A
    - 辅助进位标志

  - Z
    - 0标志位
    - 将EAX的值设置为0xFFFFFFFF  (十进制的-1)
    - 在使用add  eax,0x1的话
    - Z的值就会变为1

  - S
    - 是一个符号标志
    - 当结果为负数  S为1

  - T

  - D

  - O        
    - 溢出标志位:当操作修改了符号位它就变为1
    - 例如: EAX为0x7fffffff    add eax,0x1
    - 十六进制有符号位0x00000000~0x7fffffff是正数
    - ​                               0x80000000~0xffffffff是负数





### 汇编指令

- nop
  - nop就是什么也不做,占别人的位置,让别人起不了作用

![1562156960749](https://blog-mamba.oss-cn-beijing.aliyuncs.com/compilation/02.png)

从这里可以看出nop的十六进制机器码就是90  这里千万不能将空余的数据填充为00



- push

  - 压栈操作
  - push  0x1
  - push  eax (寄存器)
  - push  [40100]  (40100位地址值)将对应地址值里面的数据压入栈中

  ![1562166734738](https://blog-mamba.oss-cn-beijing.aliyuncs.com/compilation/03.png)

- pop

  - 弹栈操作
  - pop eax 将栈顶的数据弹给寄存器eax
  - pop ecx 将栈顶的数据弹给寄存器ecx
  - pop edx 将栈顶的数据弹给寄存器edx
  - pop ebx 将栈顶的数据弹给寄存器ebx





- pushad(32位)

  - 把通用寄存器里面的数据依次压入栈中

  - 压栈从上向下

  - 备份

    

- popad(32位)

  - 把通用寄存器里面的数据依次从栈中弹出来
  - 弹栈从下到上
  - 还原



- pusha(16位)
  - 把通用寄存器里面的数据依次压入栈中
  - 压栈从上向下
  - 备份



- popa(16位)
  - 把通用寄存器里面的数据依次从栈中弹出来
  - 弹栈从下到上
  - 还原



- mov 
  
- 赋值操作
  
- mov eax,ecx

  - 将4字节的ecx赋值给4字节的eax

- mov    al,cl

  - 将ecx的低位cx(最后两位,一个字节)赋值给eax的低位ax(最后两位,一个字节)

- mov  [402000] , eax

  - 将eax的值赋值给地址402000的位置

  - 默认编译成mov dword ptr ds:[402000],eax

  - mov byte ptr ds:[0x40200],ax

    

- movsx  eax,bx
  - 如果前面的数所占据的字节数比后面数大后面的数会把值传给它以后剩下不满的地方填充符号位
  - example:
    - EAX = 00000000;
    - EBX = 0000A123;
    - 首先将BX转化为二进制‭1010  0001  0010  0011‬
    - 我们可以看到EBX的符号位是1就说明这个是一个负数
    - 然后将BX赋值给EAX就是FFFF A123
  - example:
    - EAX = 00000000;
    - EBX = 00001234;
    - 首先将BX转化为二进制‭0001  0010  0011  0100‬
    - 我们可以看到EBX的符号位是0就说明这个是一个正数
    - 然后将BX赋值给EAX就是0000 1234
  - example:
    - EAX = 00000000;
    - EBX = 55551234;
    - 首先将BX转化为二进制0001  0010  0011  0100‬
    - 我们可以看到EBX的符号位是0就说明这个是一个正数
    - 然后将BX赋值给EAX还是0000 1234

- movzx  eax,bx   zero
  - 如果前面的数所占据的字节数比后面数大后面的数会把值传给它以后剩下不满的地方填充0
  - example:
    - EAX = 00000000;
    - EBX = 5555A123;
    - 首先将BX转化为二进制0001  0010  0011  0100‬
    - 然后将BX赋值给EAX,剩下的地方都补0,结果为0000A123

​    

- lea 
  - 格式   lea 寄存器,[地址]
  - 它和mov有点不同中括号碰上lea时中括号不再起作用了相当于没有
  - lea eax,[exc+0x16]
  - 将exc的地址+0x16 再把地址交给eax



- xchg
  - 交换命令
  - xchg  寄存器或者地址   寄存器
  - xchg  EAX  ECX
  - xchg  401004  ECX

### 数学指令

- add(加法)
- add eax,x0333
  - eax = eax+0x333
- add eax,ecx
  - eax = eax + ecx



- sub(减法)
- sub eax,0x333
  - eax = eax-0x333
- sub eax,ecx
  - eax = eax-ecx



- adc 
  - 带上进位的加法
  - adc eax,0x5
    - eax+0x5+进位标志符C的值
- sbb
  - 带上进位的减法
  - sbb eax,0x5
    - eax-0x5-进位标志符C的值



- inc 
  - 自增
  - inc eax
  - eax = eax +1



- dec
  - 自减
  - dec [402000]
  - dec eax
  - dec = dec -1



- mul
  - 无符号乘法
  - 默认和eax做乘法
  - mul ecx
  - example:
    - EAX = FFFFFFF9
    - ECX = 0x5
    - 相乘结果为:‭4  FFFF  FFDD‬
    - 然后将得出来的结果从低位到 高位分别放在EAX和EDX中
    - 低位为FFFF FFDD放入EAX中
    - 高位为4 不足补0 得出 00000004放入EDX中





- div
  - 无符号除法
  - 默认EAX做被除数
  - div cl(ECX低位,最后两位)
  - example(8位):
    - div cl
    - EAX = 00000017(十进制的23)
    - ECX = 00000003
    - 结果为商7余2
    - 余数放在AH里面商放在AL里面
    - EAX为00000207
  - example(16位):
    - div cx
    - EAX = 00000017(十进制的23)
    - ECX = 00000003
    - 结果为商7余2
    - 商放在AX里面余数放在DX里面
    - EAX为 00000007
    - EDX为00000002
  - example(32位):
    - div ecx
    - EAX = 00000017(十进制的23)
    - ECX = 00000003
    - 结果为商7余2
    - 商放在EAX里面余数放在EDX里面
    - EAX为 00000007
    - EDX为00000002  





- IMUL
  - 有符号乘法
  - 单操作数
    - example
      - imul	CL
      - EAX = FFFFFFFB = -5(十进制)
      - ECL = 00000002 = 2(十进制) 
      - AL = CL * AL
      - 结果AL = F6
      - 所以EAX = FFFFFFF6 = -10(十进制)
      - 如果是和imul ECL
      - 那么EAX和EDX都会发生变化
  - 双操作数
    - example
      - imul AX,CX
      - EAX = FFFFFFF6 = -10(十进制)
      - ECL = 00000002 = 2(十进制) 
      - AX = AX * CX
      - 结果EAX = FFFFFFEC = -20(十进制)
  - 三操作数
    - example
      - imul 操作数	通用寄存器或内存位置	立即数
      - 乘积存储到目标操作数
      - imul  AX,CX,0x2
      - 将cx和0x2相乘结果放到AX当中