---
title: 汇编大法
top: 9977
tags: []
date: 2019-03-09 23:11:21
permalink:
categories: 逆向
image:

---

<p class="description"></p>
<meta name="referrer" content="no-referrer" />
<img src="http://blog-mamba.oss-cn-beijing.aliyuncs.com/springboot/title.png">

<!-- more -->

Windows逆向环境搭建

```

```

### 寄存器1

- ollydbg的简介

![1562135783188](https://blog-mamba.oss-cn-beijing.aliyuncs.com/compilation/01.png)



- 寄存器

  - EAX
  
  - ECX
  
  - EBX

  - ESP 
  
    - 它永远指向堆栈窗口的最顶端(灰低黑字的那一行)
  
  - EBP

  - ESI

  - EDI

  - EIP
  
    - 指向当前即将要执行的指令,在CPU窗口有对应的地址值,CPU下次就要执行这个地址的指令
  - EIP是没有修改数值的菜单的,只能在CPU窗口的某一行右键此处为新EIP才可以改变EIP的值
    
    
  
- 32位寄存器(FFFFFFFF转换为二进制是32个1)

  - EAX :  12345678 (十六进制的数)
  -   AX :           5678
  -   AH :          56
  -   AL  :              78

  如果碰到cmp al,bl

  ​	比较的就是后两位78

  这种高八位  低八位只能用在EAX  ECX  EDX  EBX身上
  
  
  
- 如何查看这些寄存器的数据呢?

  - 在command窗口中输入? EAX      ?  AX      ?AH    ?AL

​	

- 灰色的代码的地方表示已经走过了,如何让它重置呢? 使用ctrl+a

### 寄存器2

- EIP的下方是**标志位寄存器**

  - C
    - 进位标志
    - 如果一个值超过最大值,那么寄存器的值就变为1
    - 无符号运算结果 最大值累加1
- 让EAX为FFFFFFFF,此时EAX是无符号位的最大值
    - add  eax,0x1  超过了无符号位的最大值
    - C标志变为1
    - EAX变为00000000 
  - P
    - 奇偶标志
    - 在CPU窗口执行一个指令,如果把结果转化为二进制以后,数字1的个数为偶数的话P就为1
    - 同样将EAX的值改为0x00000000  add eax,0x1
    - 那么EAX的值为00000001
    - 同时P的值为0
  - 当EAX的值达到0x00000011时
    - P的值也达到了1
    - 如果想多次添加1只需要在CPU的窗口使用设置新的EIP,然后在使用F8
- A
    - 辅助进位标志
  - Z
    - 0标志位
    - 将EAX的值设置为0xFFFFFFFF  (有符号十进制的-1)
    - 在使用add  eax,0x1的话
  - Z的值就会变为1
  - S
    - 是一个符号标志
    - 此时s标志位为0
- 让EAX为FFFFFFF8有符号位为-8  
    - 使用 add eax,0x1
  - 此时结果为-7
    - 当结果为负数  S为1
- T
  - 跟踪标志位
  - D
    - 方向标志位
  - O        
    - 溢出标志位:当操作修改了符号位它就变为1
    - 例如: EAX为0x7fffffff    add eax,0x1
    - 十六进制有符号位0x00000000~0x7fffffff是正数
    - ​                               0x80000000~0xffffffff是负数





### 汇编指令

- nop
  - 空指令
  - nop就是什么也不做,占别人的位置,让别人起不了作用

![1566232759066](C:\Users\85896\AppData\Roaming\Typora\typora-user-images\1566232759066.png)

![1566233001070](C:\Users\85896\AppData\Roaming\Typora\typora-user-images\1566233001070.png)

![1562156960749](https://blog-mamba.oss-cn-beijing.aliyuncs.com/compilation/02.png)

从这里可以看出nop的十六进制机器码就是90  这里千万不能将空余的数据填充为00,  00是有指令的



- push

  - 压栈操作
  - push  0x1
  - push  eax (寄存器)   eax赋值为12345678
  - push  0x00401000     将0x00401000这个值压入到堆栈中   OD会帮我们解释0x00401000是指向 哪里
  - push  [401000]  (401000是地址值)将对应地址值里面的数据压入栈中

  ![1562166734738](https://blog-mamba.oss-cn-beijing.aliyuncs.com/compilation/03.png)

  push的字节数是4  取决于当前操作系统的位数32位      

  数据窗口的hex数据和  堆栈地址的数据是成镜面对称的

​		数据窗口的hex数据和  寄存器的数据是成镜面对称的

- pop

  - 弹栈操作
  
  - 初始化
  
    ![1566266069576](C:\Users\85896\AppData\Roaming\Typora\typora-user-images\1566266069576.png)
  
  - pop eax 将栈顶的数据弹给寄存器eax
  
    ![1566266213750](C:\Users\85896\AppData\Roaming\Typora\typora-user-images\1566266213750.png)
  
  - pop ecx 将栈顶的数据弹给寄存器ecx
  
    ![1566266292511](C:\Users\85896\AppData\Roaming\Typora\typora-user-images\1566266292511.png)
  
  - pop edx 将栈顶的数据弹给寄存器edx
  
    ![1566266359146](C:\Users\85896\AppData\Roaming\Typora\typora-user-images\1566266359146.png)
  
  - pop ebx 将栈顶的数据弹给寄存器ebx
  
    ![1566266458102](C:\Users\85896\AppData\Roaming\Typora\typora-user-images\1566266458102.png)



- pushad(32位)   (保护现场,将通用寄存器中的数据保存到对参数据当中,然后你可以随便修改寄存器的值了)

  - 把通用寄存器里面的数据依次压入栈中
  - 我pushad一条指令就相当于执行了:
  - push EAX
  - push ECX
  - push EDX
  - push EBX
  - push ESP
  - push EBP
  - push ESI
  - push EDI
  - 压栈从上向下
  - 备份

  执行pushad之前:

  ![1566268651409](C:\Users\85896\AppData\Roaming\Typora\typora-user-images\1566268651409.png)

  执行pushad之后:

  ![1566268874413](C:\Users\85896\AppData\Roaming\Typora\typora-user-images\1566268874413.png)

  

- popad(32位)

  - 把栈中的数据依次倒序弹出给通用寄存器
  - 执行popad一条指令相当于执行了下面的8条指令
  - pop EDI
  - pop ESI
  - pop EBP
  - pop ESP
  - pop EBX
  - pop EDX
  - pop ECX
  - pop EAX
  - 弹栈从下到上
  - 还原

执行popad之前:

![1566271879786](C:\Users\85896\AppData\Roaming\Typora\typora-user-images\1566271879786.png)

执行popad之后:

![1566272738412](C:\Users\85896\AppData\Roaming\Typora\typora-user-images\1566272738412.png)

相当于执行了pop EDI 

​					   pop  ESI

​					   pop  EBP

​					   pop  ESP

​					   pop  EBX

​					   pop  EDX

​					   pop  ECX

​					   pop  EAX

- pusha(16位)
  - 把通用寄存器里面的数据依次压入栈中
  - 执行popa一条指令相当于执行了下面的8条指令
  - push AX
  - push CX
  - push DX
  - push BX
  - push SP
  - push BP
  - push SI
  - push DI
  - 压栈从上向下
  - 备份



- popa(16位)
  - 把通用寄存器里面的数据依次从栈中弹出来
  - 执行popa一条指令相当于执行了下面的8条指令
  - pop DI
  - pop SI
  - pop BP
  - pop SP
  - pop BX
  - pop DX
  - pop CX
  - pop AX
  - 弹栈从下到上
  - 还原



- mov 
  
- 赋值操作
  
- mov eax,ecx               将4字节的ecx赋值给4字节的eax

  - 赋值之前:
  - ![1566283477459](C:\Users\85896\AppData\Roaming\Typora\typora-user-images\1566283477459.png)
  - 赋值之后:
  - ![1566283539975](C:\Users\85896\AppData\Roaming\Typora\typora-user-images\1566283539975.png)

  

- mov  ax,cx

  - 将ecx的低位cx(最后四位,两个字节)赋值给eax的低位ax(最后四位,两个字节)
  - 赋值之前:

  ![1566284815721](C:\Users\85896\AppData\Roaming\Typora\typora-user-images\1566284815721.png)

  - 赋值之后:

  ![1566284877064](C:\Users\85896\AppData\Roaming\Typora\typora-user-images\1566284877064.png)

  

- mov    al,cl

  - 将ecx的低位cl(最后两位,一个字节)赋值给eax的低位al(最后两位,一个字节)
  - 赋值之前

  ![1566285304937](C:\Users\85896\AppData\Roaming\Typora\typora-user-images\1566285304937.png)

  - 赋值之后

  ![1566285452340](C:\Users\85896\AppData\Roaming\Typora\typora-user-images\1566285452340.png)

- mov  [402000] , eax

  - 将eax的值赋值给地址402000的位置

  - 默认编译成mov dword ptr ds:[402000],eax         dword代表4字节 

  - mov word ptr ds:[402000],eax                             word代表2字节

  -  

  - mov byte ptr ds:[0x40200],ax

    

- movsx  eax,bx
  - 如果前面的数所占据的字节数比后面数大后面的数会把值传给它以后剩下不满的地方填充符号位
  - example:
    - EAX = 00000000;
    - EBX = 0000A123;
    - 首先将BX转化为二进制‭1010  0001  0010  0011‬
    - 我们可以看到EBX的符号位是1就说明这个是一个负数
    - 然后将BX赋值给EAX就是FFFF A123
  - example:
    - EAX = 00000000;
    - EBX = 00001234;
    - 首先将BX转化为二进制‭0001  0010  0011  0100‬
    - 我们可以看到EBX的符号位是0就说明这个是一个正数
    - 然后将BX赋值给EAX就是0000 1234
  - example:
    - EAX = 00000000;
    - EBX = 55551234;
    - 首先将BX转化为二进制0001  0010  0011  0100‬
    - 我们可以看到EBX的符号位是0就说明这个是一个正数
    - 然后将BX赋值给EAX还是0000 1234

- movzx  eax,bx   zero
  - 如果前面的数所占据的字节数比后面数大后面的数会把值传给它以后剩下不满的地方填充0
  - example:
    - EAX = 00000000;
    - EBX = 5555A123;
    - 首先将BX转化为二进制0001  0010  0011  0100‬
    - 然后将BX赋值给EAX,剩下的地方都补0,结果为0000A123

​    

- lea 
  - 格式   lea 寄存器,[地址]
  - 它和mov有点不同中括号碰上lea时中括号不再起作用了相当于没有
  - lea eax,[exc+0x16]
  - 将exc的地址+0x16 再把地址交给eax



- xchg
  - 交换命令
  - xchg  寄存器或者地址   寄存器
  - xchg  EAX  ECX
  - xchg  401004  ECX

### 数学指令

- add(加法)
- add eax,x0333
  - eax = eax+0x333
- add eax,ecx
  - eax = eax + ecx



- sub(减法)
- sub eax,0x333
  - eax = eax-0x333
- sub eax,ecx
  - eax = eax-ecx



- adc 
  - 带上进位的加法
  - adc eax,0x5
    - eax+0x5+进位标志符C的值
- sbb
  - 带上进位的减法
  - sbb eax,0x5
    - eax-0x5-进位标志符C的值



- inc 
  - 自增
  - inc eax
  - eax = eax +1



- dec
  - 自减
  - dec [402000]
  - dec eax
  - dec = dec -1



- mul
  - 无符号乘法
  - 默认和eax做乘法
  - mul ecx
  - example:
    - EAX = FFFFFFF9
    - ECX = 0x5
    - 相乘结果为:‭4  FFFF  FFDD‬
    - 然后将得出来的结果从低位到 高位分别放在EAX和EDX中
    - 低位为FFFF FFDD放入EAX中
    - 高位为4 不足补0 得出 00000004放入EDX中





- div
  - 无符号除法
  - 默认EAX做被除数
  - div cl(ECX低位,最后两位)
  - example(8位):
    - div cl
    - EAX = 00000017(十进制的23)
    - ECX = 00000003
    - 结果为商7余2
    - 余数放在AH里面商放在AL里面
    - EAX为00000207
  - example(16位):
    - div cx
    - EAX = 00000017(十进制的23)
    - ECX = 00000003
    - 结果为商7余2
    - 商放在AX里面余数放在DX里面
    - EAX为 00000007
    - EDX为00000002
  - example(32位):
    - div ecx
    - EAX = 00000017(十进制的23)
    - ECX = 00000003
    - 结果为商7余2
    - 商放在EAX里面余数放在EDX里面
    - EAX为 00000007
    - EDX为00000002  





- IMUL
  - 有符号乘法
  - 单操作数
    - example
      - imul	CL
      - EAX = FFFFFFFB = -5(十进制)
      - ECL = 00000002 = 2(十进制) 
      - AL = CL * AL
      - 结果AL = F6
      - 所以EAX = FFFFFFF6 = -10(十进制)
      - 如果是和imul ECL
      - 那么EAX和EDX都会发生变化
  - 双操作数
    - example
      - imul AX,CX
      - EAX = FFFFFFF6 = -10(十进制)
      - ECL = 00000002 = 2(十进制) 
      - AX = AX * CX
      - 结果EAX = FFFFFFEC = -20(十进制)
  - 三操作数
    - example
      - imul 操作数	通用寄存器或内存位置	立即数
      - 乘积存储到目标操作数
      - imul  AX,CX,0x2
      - 将cx和0x2相乘结果放到AX当中