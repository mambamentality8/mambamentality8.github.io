# 面试之常用注解

### @Component ：

标准一个普通的spring Bean类。

### @Controller：

标注一个控制器组件类。

### @Service：

标注一个业务逻辑组件类。

### @Repository：

标注一个DAO组件类。



@Component、@Repository、@Service、@Controller实质上属于同一类注解，用法相同，功能相同，区别在于标识组件的类型。

@Component可以代替@Repository、@Service、@Controller，因为这三个注解是被@Component标注的。

```
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component
public @interface Controller {
    String value() default "";
}
```

其它三个注解同理可得

#### 注意点:

被注解的java类当做Bean实例，Bean实例的名称默认是Bean类的首字母小写，其他部分不变。

指定了某些类可作为Spring Bean类使用后，最好还需要让spring搜索指定路径。在主配置类上使用如下注解:

```
@Configuration

@ComponentScan(value="com.xxx")默认扫描子包
```

#### 例子:

我们web工程中，新建一个`BookController`类，具体如下：

```
package com.itwell.controller;
// 省略了包的导入
@Controller
public class BookController {
    @Autowired
    private BookService bookService;
}
```

`BookService`类

```
package com.itwell.service;
@Service
public class BookService {
    @Autowired
    private BookDao bookDao;
    public void print(){
        System.out.println(bookDao);
    }
    @Override
    public String toString() {
        return "BookService [bookDao=" + bookDao + "]";
    }

}
```

最后是`BookDao`类

```
package com.itwell.dao;
//名字默认是类名首字母小写
@Repository
public class BookDao {
    private String lable = "1";
    public String getLable() {
        return lable;
    }
    public void setLable(String lable) {
        this.lable = lable;
    }
    @Override
    public String toString() {
        return "BookDao [lable=" + lable + "]";
    }
}
```

我们新建`MainConfig`类，作为我们的配置类

```
package com.itwell.config;
//配置类==配置文件
@Configuration  //告诉Spring这是一个配置类 让这个类等同于xml
@ComponentScan(value="com.itwell") // 注意这一行。
public class MainConfig {
    //给容器中注册一个Bean;类型为返回值的类型，id默认是用方法名作为id
    @Bean(name = "person")
    public Person person01(){
        return new Person("lisi", 20);
    }
}
```

我们写个测试方法：

```
public class IOCTest {

    @SuppressWarnings("resource")
    @Test
    public void test01(){
        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig.class);
        String[] definitionNames = applicationContext.getBeanDefinitionNames();
        for (String name : definitionNames) {
            System.out.println(name);
        }
    }
}
```

加载配置类，并获取到容器中所有的Bean的名字，然后遍历进行打印

我们看下打印结果

```
org.springframework.context.annotation.internalConfigurationAnnotationProcessor
org.springframework.context.annotation.internalAutowiredAnnotationProcessor
org.springframework.context.annotation.internalRequiredAnnotationProcessor
org.springframework.context.annotation.internalCommonAnnotationProcessor
org.springframework.context.event.internalEventListenerProcessor
org.springframework.context.event.internalEventListenerFactory // 这几个都是spring容器本身的
mainConfig
bookController
bookDao
bookService
person
```

我们可以看到将com.itwell下所有的bean都已经扫描了进来，这里说一下MainConfig这个配置类，也在扫描的包下。它的类上有个注解@Configuration，表示配置类也是一个bean。还有个person是我们在@Bean注解定义的Bean.

### @Autowired

属于Spring 的org.springframework.beans.factory.annotation包下,可用于为类的属性、构造器、方法进行注值

### @Resource

不属于spring的注解，而是来自于JSR-250位于java.annotation包下，使用该annotation为目标bean指定协作者Bean。

#### 相同点

@Resource的作用相当于@Autowired，均可标注在字段或属性的setter方法上。

#### 不同点

1.@Autowired是Spring的注解，@Resource是javax.annotation注解，而是来自于JSR-250，J2EE提供，需要JDK1.6及以上。

2.@Autowired只按照Type 注入；@Resource默认按Name自动注入，也提供按照Type 注入；

3.@Autowired注解**默认按照类型装配**，如果容器中包含多个同一类型的Bean，那么启动容器时会报找不到指定类型bean的异常，解决办法是结合**@Qualifier**注解进行限定，指定注入的bean名称。

@Resource有两个中重要的属性：name和type。name属性指定byName，如果没有指定name属性，当注解标注在字段上，即默认取字段的名称作为bean名称寻找依赖对象，当注解标注在属性的setter方法上，即默认取属性名作为bean名称寻找依赖对象。

需要注意的是，@Resource如果没有指定name属性，并且按照默认的名称仍然找不到依赖对象时， @Resource注解会回退到按类型装配。

#### 总结

@Resource注解的使用性更为灵活，可指定名称，也可以指定类型 ；@Autowired注解进行装配容易抛出异常，特别是装配的bean类型有多个的时候，而解决的办法是需要在增加@Qualifier进行限定。

### @Configuration

使用@Configuration 来注解类表示类可以被 Spring 的 IoC 容器所使用,相当于这个类就是一个XML

### @Bean

结合@Configuration使用,作用于方法上返回一个对象

#### 例子:

```
@Configuration
public class AppConfig {
    @Bean
    public MyService myService() {
        return new MyServiceImpl();
    }
}
```

相当于

```
<beans>
    <bean id="myService" class="com.itwell.services.MyServiceImpl"/>
</beans>
```

# spring MVC模块注解

###  @RequestMapping

这个注解用于将url映射到整个处理类或者特定的处理请求的方法。可以只用通配符！

@RequestMapping 既可以作用在类级别，也可以作用在方法级别。当它定义在类级别时就是父路由,当它定义在方法级别时就是子路由。

### @RequestParam

@RequestParam用于获取参数，可获取?userName=zhangsan这种后面的参数值

### @PathVariable

获取一个url 地址中的一部分值

### @RequestBody

用来接收前端传递给后端的请求体中的json字符串中的数据

### @ResponseBody

将后台java对象以json字符串格式输出给前台

### @RestController

相当于@RequestMapping和@ResponseBody的组合